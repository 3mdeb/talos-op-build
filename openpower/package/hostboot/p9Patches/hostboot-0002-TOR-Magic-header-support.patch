From 583cf99ed879916632f823444129c21056267d4c Mon Sep 17 00:00:00 2001
From: Claus Michael Olsen <cmolsen@us.ibm.com>
Date: Tue, 24 Jan 2017 23:42:50 -0600
Subject: [PATCH] TOR Magic header support

HW-Image-Coreq=Yes
SBE-Image-Coreq=No (SBE image is back compatible)

This commit adds an 12-byte header to all TOR ring sections:
- for improved self-containment of TOR ring sections incl
  stand-alone ring sections like .overrides which, currently,
  has no meaningful size info associated with it in the PNOR,
- to support a more data-driven implementation of TOR API,
- to eliminate the current usage of XIP_MAGIC ids to inform the
  TOR APIs which ring section they are dealing with, and
- to improve debugging binary ring sections.

The TOR header expands on the current TorNumDdLevels field in the
HW ring section and is added to all other ring sections as well,
e.g. for the SBE and OVRD ring sections.  Most importantly, the
TOR header adds the TOR magic number which is unique for each
possible TOR ring section. Also, of quite practical importance,
a size field has been added so that the size of a true standalone
section like .overrides can be extracted (since its size in PNOR
is not indicative of its size).

Further, to support the use of ddLevel and chipType in the TOR
header fields, these two data points need to be always supplied
whenever calling ring_apply. Thus, updates have been made to the
ring_apply.mk file as well as the override .pl script.  While
making these changes, we also decided to change the --type arg
to the --bOverrides arg to make the arguments being passed less
confusing in view of the Centaur commit that's coming and its
demands to make codes less data dependent, incl make and script
files which should simply inform the functional intent of the
"user". The user shouldn't presume it knows about which specific
type of ring section needs to be produced.

Further, the DD level block struct has been increased from 8B
to 12B to avoid the unnecessarily complex merging of the
ddLevel and offset into the same 4B field. It's included in
this commit since this is also going to break the lab and
because the required code changes are in the same places
where the code changes needed for the TOR header are.

Further, xip_tool has been updated to support the new TOR
header so that it can be called by supplying a standalone
ring section, such as overrides.bin. Various changes have
been made in xip_tool's dissect section to support overrides
as well.

This code uses many  of the code changes in 33778 except
changes to p9_tor.C|H are at a bare minimum focusing on the
functional changes and keeping any cleanups to a minimum changing
only some variable names associated with the functional changes
for improved readability of the code.

CMVC-Prereq: 1034144
CMVC-Prereq: 1035575
Change-Id: I29ba8905ac55dad5c10878a94fb94468e5580ea0
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/35372
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: HWSV CI <hwsv-ci+hostboot@us.ibm.com>
Reviewed-by: Jennifer A. Stofer <stofer@us.ibm.com>
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/37994
Reviewed-by: Christian R. Geddes <crgeddes@us.ibm.com>
---
 src/build/citest/etc/bbuild                        |   2 +-
 src/build/citest/etc/workarounds.postsimsetup      |  23 +-
 .../p9/procedures/hwp/customize/p9_xip_customize.C |   1 -
 .../p9/procedures/hwp/pm/p9_hcode_image_build.C    |   7 -
 src/import/chips/p9/utils/imageProcs/p9_ringId.H   |  23 +-
 src/import/chips/p9/utils/imageProcs/p9_tor.C      | 362 +++++++++++----------
 src/import/chips/p9/utils/imageProcs/p9_tor.H      |  97 +++---
 7 files changed, 286 insertions(+), 229 deletions(-)

diff --git a/src/build/citest/etc/bbuild b/src/build/citest/etc/bbuild
index aaea664..fac4cb6 100644
--- a/src/build/citest/etc/bbuild
+++ b/src/build/citest/etc/bbuild
@@ -1,3 +1,3 @@
-/esw/fips910/Builds/b0908a_1738.910
+/esw/fips910/Builds/b0930a_1740.910
 
 
diff --git a/src/build/citest/etc/workarounds.postsimsetup b/src/build/citest/etc/workarounds.postsimsetup
index cced000..70d7f20 100755
--- a/src/build/citest/etc/workarounds.postsimsetup
+++ b/src/build/citest/etc/workarounds.postsimsetup
@@ -32,22 +32,29 @@
 #mkdir -p $sb/simu/data/cec-chip/
 #cp $BACKING_BUILD/src/simu/data/cec-chip/base_cec_chip_file $sb/simu/data/cec-chip
 #patch -p0 $sb/simu/data/cec-chip/base_cec_chip_file $PROJECT_ROOT/src/build/citest/etc/patches/my_patch_File
-#pull in new actions in p9_memory.act RTC 171066
-#pull in SBE makefile change for DD2.1
-sbex -t 1032604
-cd $sb/sbei/sbfw/
-mk -a && mk install_all
-cd -
+
 
 #changes needed for Cumulus
 #@TODO RTC:178949
 echo "Applying SIMICS workaround to support Cumulus"
 sbex -t 1031560
-sbex -t 1032617
-sbex -t 1033442
 cd $sb/simu
 mk -a
 
 echo "Copying centaur and p9c action files"
 sbex -t 1032952
 sbex -t 1033805
+
+#pull in href tor
+sbex -t 1035576
+#pull in hwsv tor
+sbex -t 1034144
+
+
+mkdir $sb/../obj/ppc/hwsv/server/buildhwpfimport/hwpf2/tools/x86_binaries -p
+cp /gsa/rchgsa/home/c/r/crgeddes/documents/hbBuild/p9_ipl_build $sb/../obj/ppc/hwsv/server/buildhwpfimport/hwpf2/tools/x86_binaries/
+
+
+
+
+
diff --git a/src/import/chips/p9/procedures/hwp/customize/p9_xip_customize.C b/src/import/chips/p9/procedures/hwp/customize/p9_xip_customize.C
index c30f31e..cd6e494 100644
--- a/src/import/chips/p9/procedures/hwp/customize/p9_xip_customize.C
+++ b/src/import/chips/p9/procedures/hwp/customize/p9_xip_customize.C
@@ -302,7 +302,6 @@ fapi2::ReturnCode get_overlays_ring(
     // Get Gptr overlay ring from overlays section into ringBuf2
     l_rc = P9_TOR::tor_get_single_ring(
                i_overlaysSection,
-               P9_XIP_MAGIC_SEEPROM,
                l_ddLevel,
                i_ringId,
                P9_TOR::SBE,
diff --git a/src/import/chips/p9/procedures/hwp/pm/p9_hcode_image_build.C b/src/import/chips/p9/procedures/hwp/pm/p9_hcode_image_build.C
index 781208b..e34a97d 100644
--- a/src/import/chips/p9/procedures/hwp/pm/p9_hcode_image_build.C
+++ b/src/import/chips/p9/procedures/hwp/pm/p9_hcode_image_build.C
@@ -1893,7 +1893,6 @@ uint32_t getPpeScanRings( void* const     i_pHwImage,
                       sgpeOvrdRings.getRingName( quadCmnOvrdRingId ) );
 
             rc = tor_get_single_ring( i_pOverride,
-                                      P9_XIP_MAGIC_SEEPROM,
                                       i_chipState.getChipLevel(),
                                       quadCmnOvrdRingId,
                                       P9_TOR::SBE,
@@ -2373,7 +2372,6 @@ fapi2::ReturnCode layoutCmnRingsForCme( Homerlayout_t*   i_pHomer,
             }
 
             rc = tor_get_single_ring( i_ringData.iv_pRingBuffer,
-                                      P9_XIP_MAGIC_CME,
                                       i_chipState.getChipLevel(),
                                       coreCmnRingId,
                                       P9_TOR::CME,
@@ -2491,7 +2489,6 @@ fapi2::ReturnCode layoutInstRingsForCme(    Homerlayout_t*   i_pHomer,
 
                 tempSize = i_ringData.iv_sizeWorkBuf1;
                 rc = tor_get_single_ring( i_ringData.iv_pRingBuffer,
-                                          P9_XIP_MAGIC_CME,
                                           i_chipState.getChipLevel(),
                                           io_cmeRings.getInstRingId(0),
                                           P9_TOR::CME,
@@ -2556,7 +2553,6 @@ fapi2::ReturnCode layoutInstRingsForCme(    Homerlayout_t*   i_pHomer,
 
                 tempSize = i_ringData.iv_sizeWorkBuf1;
                 rc = tor_get_single_ring( i_ringData.iv_pRingBuffer,
-                                          P9_XIP_MAGIC_CME,
                                           i_chipState.getChipLevel(),
                                           io_cmeRings.getInstRingId(0),
                                           P9_TOR::CME,
@@ -2667,7 +2663,6 @@ fapi2::ReturnCode layoutCmeScanOverride( Homerlayout_t*   i_pHomer,
                       cmeOvrdRings.getRingName( coreCmnOvrdRingId ) );
 
             rc = tor_get_single_ring( i_pOverride,
-                                      P9_XIP_MAGIC_SEEPROM,
                                       i_chipState.getChipLevel(),
                                       coreCmnOvrdRingId,
                                       P9_TOR::SBE,
@@ -3019,7 +3014,6 @@ fapi2::ReturnCode layoutCmnRingsForSgpe( Homerlayout_t*     i_pHomer,
                 l_ringVariant = BASE;
             }
             rc = tor_get_single_ring( i_ringData.iv_pRingBuffer,
-                                      P9_XIP_MAGIC_SGPE,
                                       i_chipState.getChipLevel(),
                                       torRingId,
                                       P9_TOR::SGPE,
@@ -3138,7 +3132,6 @@ fapi2::ReturnCode layoutInstRingsForSgpe( Homerlayout_t*     i_pHomer,
 
                 quadSpecRingId = io_sgpeRings.getInstRingId( ringIndex );
                 rc = tor_get_single_ring( i_ringData.iv_pRingBuffer,
-                                          P9_XIP_MAGIC_SGPE,
                                           i_chipState.getChipLevel(),
                                           quadSpecRingId,
                                           P9_TOR::SGPE,
diff --git a/src/import/chips/p9/utils/imageProcs/p9_ringId.H b/src/import/chips/p9/utils/imageProcs/p9_ringId.H
index 2c29ba3..d78e52b 100644
--- a/src/import/chips/p9/utils/imageProcs/p9_ringId.H
+++ b/src/import/chips/p9/utils/imageProcs/p9_ringId.H
@@ -68,9 +68,10 @@ typedef enum RingVariant   // Base variables
     NOT_VALID = 0xff
 } RingVariant_t;
 
+#define P9_RINGID_VARIANT_ORDER_SIZE 3
 typedef struct
 {
-    uint8_t  variant[3];
+    uint8_t  variant[P9_RINGID_VARIANT_ORDER_SIZE];
 } RingVariantOrder;
 
 
@@ -244,6 +245,7 @@ const uint8_t INSTANCE_RING_MASK = 0x7F;
 
 namespace PERV
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -289,6 +291,7 @@ static const CHIPLET_DATA g_pervData =
 
 namespace N0
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -318,12 +321,13 @@ static const CHIPLET_DATA g_n0Data =
     2, // N0 Chiplet ID is 2.
     9, // 9 common rings for N0 Chiplet
     3, // 3 instance specific rings for N0 chiplet
-    3
+    3  // FIXME: number of variants? doesn't match RingVariants below!
 };
 };
 
 namespace N1
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -363,6 +367,7 @@ static const CHIPLET_DATA g_n1Data =
 
 namespace N2
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -398,6 +403,7 @@ static const CHIPLET_DATA g_n2Data =
 
 namespace N3
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -434,6 +440,7 @@ static const CHIPLET_DATA g_n3Data =
 
 namespace XB
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -476,6 +483,7 @@ static const CHIPLET_DATA g_xbData =
 
 namespace MC
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -519,6 +527,7 @@ static const CHIPLET_DATA g_mcData =
 
 namespace OB0
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -551,6 +560,7 @@ static const CHIPLET_DATA g_ob0Data =
 
 namespace OB1
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -584,6 +594,7 @@ static const CHIPLET_DATA g_ob1Data =
 
 namespace OB2
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -616,6 +627,7 @@ static const CHIPLET_DATA g_ob2Data =
 
 namespace OB3
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -647,6 +659,7 @@ static const CHIPLET_DATA g_ob3Data =
 }; // end of namespace OB2
 namespace PCI0
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -676,6 +689,7 @@ static const CHIPLET_DATA g_pci0Data =
 
 namespace PCI1
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -705,6 +719,7 @@ static const CHIPLET_DATA g_pci1Data =
 
 namespace PCI2
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -735,6 +750,7 @@ static const CHIPLET_DATA g_pci2Data =
 
 namespace EQ
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -832,6 +848,7 @@ static const CHIPLET_DATA g_eqData =
 
 namespace EC
 {
+// FIXME: this struct is nonsense - no one uses these fields (we only need the variant number)
 struct RingVariants
 {
     uint16_t iv_base;
@@ -868,7 +885,7 @@ static const uint8_t INVALID_RING = 0xFF;
 #ifndef __PPE__
 struct ringProperties_t
 {
-    uint8_t iv_torOffSet;
+    uint8_t iv_torOffSet;  // FIXME: misnomer
     char iv_name[50];
     CHIPLET_TYPE iv_type;
 };
diff --git a/src/import/chips/p9/utils/imageProcs/p9_tor.C b/src/import/chips/p9/utils/imageProcs/p9_tor.C
index b9b793a..d4879c8 100644
--- a/src/import/chips/p9/utils/imageProcs/p9_tor.C
+++ b/src/import/chips/p9/utils/imageProcs/p9_tor.C
@@ -41,9 +41,7 @@
 // While using tor_tor_get_block_of_rings and tor_get_single_ring API,
 // it is used pass by value
 //
-#include "p9_ringId.H"
 #include "p9_tor.H"
-#include "p9_xip_image.h"
 #include "p9_scan_compression.H"
 #include "p9_infrastruct_help.H"
 
@@ -72,7 +70,6 @@ const char* ringVariantName[] = { "BASE",
 //////////////////////////////////////////////////////////////////////////////////
 static
 int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section ptr
-                             uint64_t        i_magic,           // Image Magic Number
                              RingID          i_ringId,          // Ring ID
                              uint16_t        i_ddLevelOffset,   // DD level offset (wrt i_ringSection)
                              RingType_t&     io_RingType,       // Common, Instance
@@ -85,11 +82,13 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                              uint32_t        i_dbgl )           // Debug option
 {
     int      rc = TOR_SUCCESS;
+    uint32_t torMagic;
     uint32_t tor_slot_no = 0; // TOR slot number (within a TOR chiplet section)
     uint16_t dd_level_offset; // Local DD level offset, if any (wrt i_ringSection)
     uint32_t acc_offset = 0;  // Accumulating offset to next TOR offset
-    uint32_t ppe_offset = 0;  // Local offset to where SBE PPE section starts
-    uint32_t cplt_offset = 0; // Local offset to where SBE chiplet section starts
+    uint32_t ppe_offset = 0;  // Local offset to where SBE PPE ring section starts
+    uint32_t ppe_cplt_offset = 0; // Local offset to where the pool of chiplets starts
+    uint32_t cplt_offset = 0; // Local offset to where a specific chiplet section starts
     uint16_t ring_offset = 0; // Local offset to where SBE ring container/block starts
     uint32_t ring_size = 0;   // Size of whole ring container/block.
     RingVariantOrder* ring_variant_order;
@@ -98,23 +97,35 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
     CHIPLET_DATA* l_cpltData;
     uint8_t l_num_variant;
 
-    if (i_magic == P9_XIP_MAGIC_HW)
+    torMagic = be32toh( ((TorHeader_t*)i_ringSection)->magic );
+
+    // Calculate the offset (wrt start of ringSection) to the SBE PPE
+    //   ring section. This offset, ppe_offset, will point to the
+    //   TORB header of the SBE PPE ring section.
+    if (torMagic == TOR_MAGIC_HW)
     {
         dd_level_offset = i_ddLevelOffset;
         ppe_offset = *(uint32_t*)((uint8_t*)i_ringSection + dd_level_offset);
         ppe_offset = be32toh(ppe_offset);
     }
-    else if (i_magic == P9_XIP_MAGIC_SEEPROM)
+    else if (torMagic == TOR_MAGIC_SBE  ||
+             torMagic == TOR_MAGIC_OVRD ||
+             torMagic == TOR_MAGIC_OVLY)
     {
         ppe_offset = 0;
         dd_level_offset = 0;
     }
     else
     {
-        MY_ERR("Magic number i_magic=0x%016lX is not valid for SBE\n", (uintptr_t)i_magic);
+        MY_ERR("torMagic=0x%08x is not valid for SBE\n", torMagic);
         return TOR_INVALID_MAGIC_NUMBER;
     }
 
+    // Calculate the offset (wrt start of ringSection) to where the
+    //   pool of chiplet offsets begins in the SBE PPE ring section,
+    //   which is right after the TORB header.
+    ppe_cplt_offset = ppe_offset + sizeof(TorHeader_t);
+
     // Looper for each SBE chiplet
     for (int iCplt = 0; iCplt < SBE_NOOF_CHIPLETS; iCplt++)
     {
@@ -129,7 +140,7 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
             return TOR_INVALID_CHIPLET;
         }
 
-        l_num_variant = (i_RingVariant == OVERRIDE || i_RingVariant == OVERLAY) ? 1 : l_num_variant;
+        l_num_variant = (torMagic == TOR_MAGIC_OVRD || torMagic == TOR_MAGIC_OVLY) ? 1 : l_num_variant;
 
         if (i_dbgl > 1)
         {
@@ -154,19 +165,20 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                            (ring_id_list_common + i)->ringName, i, iVariant);
                 }
 
-                if ((strcmp( (ring_id_list_common + i)->ringName,
-                             RING_PROPERTIES[i_ringId].iv_name) == 0)
-                    && ( i_RingVariant == ring_variant_order->variant[iVariant]
-                         || ( (i_RingVariant == OVERRIDE || i_RingVariant == OVERLAY) && i_magic == P9_XIP_MAGIC_SEEPROM)))
+                if ( ( strcmp( (ring_id_list_common + i)->ringName,
+                               RING_PROPERTIES[i_ringId].iv_name) == 0 ) &&
+                     ( i_RingVariant == ring_variant_order->variant[iVariant] ||
+                       torMagic == TOR_MAGIC_OVRD ||
+                       torMagic == TOR_MAGIC_OVLY ) )
                 {
                     strcpy(o_ringName, RING_PROPERTIES[i_ringId].iv_name);
-
-                    acc_offset = dd_level_offset + ppe_offset + iCplt * sizeof(TorPpeBlock_t);
+                    acc_offset = dd_level_offset +
+                                 ppe_cplt_offset +
+                                 iCplt * sizeof(TorPpeBlock_t);
                     cplt_offset =  *(uint32_t*)( (uint8_t*)i_ringSection +
                                                  acc_offset );
                     cplt_offset = be32toh(cplt_offset);
-
-                    acc_offset = dd_level_offset + ppe_offset + cplt_offset;
+                    acc_offset = dd_level_offset + ppe_cplt_offset + cplt_offset;
                     ring_offset = *(uint16_t*)( (uint8_t*)i_ringSection +
                                                 acc_offset +
                                                 tor_slot_no * sizeof(ring_offset) );
@@ -175,7 +187,7 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                     if (i_RingBlockType == GET_SINGLE_RING)
                     {
                         acc_offset = dd_level_offset +
-                                     ppe_offset +
+                                     ppe_cplt_offset +
                                      cplt_offset +
                                      ring_offset;
                         ring_size = be16toh( ((CompressedScanData*)
@@ -233,7 +245,7 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                                    "   Chiplet section's offset to RS4 header = 0x%08x \n"
                                    "   Full offset to RS4 header = 0x%08x \n"
                                    "   Ring size = 0x%08x \n",
-                                   i, dd_level_offset, ppe_offset, cplt_offset, ring_offset, acc_offset, ring_size);
+                                   i, dd_level_offset, ppe_cplt_offset, cplt_offset, ring_offset, acc_offset, ring_size);
                         }
 
                         return rc;
@@ -296,14 +308,16 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                                 strcpy(o_ringName, RING_PROPERTIES[i_ringId].iv_name);
 
                                 acc_offset = dd_level_offset +
-                                             ppe_offset +
+                                             ppe_cplt_offset +
                                              iCplt * sizeof(TorPpeBlock_t) +
                                              sizeof(cplt_offset); // Jump to instance offset
                                 cplt_offset =  *(uint32_t*)( (uint8_t*)i_ringSection +
                                                              acc_offset );
                                 cplt_offset = be32toh(cplt_offset);
 
-                                acc_offset = cplt_offset + dd_level_offset + ppe_offset;
+                                acc_offset = cplt_offset +
+                                             dd_level_offset +
+                                             ppe_cplt_offset;
                                 ring_offset = *(uint16_t*)( (uint8_t*)i_ringSection +
                                                             acc_offset +
                                                             tor_slot_no * sizeof(ring_offset) );
@@ -312,7 +326,7 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                                 if (i_RingBlockType == GET_SINGLE_RING)
                                 {
                                     acc_offset = dd_level_offset +
-                                                 ppe_offset +
+                                                 ppe_cplt_offset +
                                                  cplt_offset +
                                                  ring_offset;
                                     ring_size = be16toh( ((CompressedScanData*)
@@ -376,7 +390,7 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
                                                "   Chiplet section's offset to RS4 header = 0x%08x \n"
                                                "   Full offset to RS4 header = 0x%08x \n"
                                                "   Ring size = 0x%08x \n",
-                                               i, dd_level_offset, ppe_offset, cplt_offset, ring_offset, acc_offset, ring_size);
+                                               i, dd_level_offset, ppe_cplt_offset, cplt_offset, ring_offset, acc_offset, ring_size);
                                     }
 
                                     return rc;
@@ -441,7 +455,6 @@ int get_ring_from_sbe_image( void*           i_ringSection,     // Ring section
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 static
 int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring section ptr
-                               uint64_t        i_magic,           // Image Magic Number
                                RingID          i_ringId,          // Ring ID
                                uint16_t        i_ddLevelOffset,   // DD level offset
                                RingType_t&     io_RingType,       // Common, Instance
@@ -453,24 +466,42 @@ int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring sectio
                                char*           o_ringName,        // Name of ring
                                uint32_t        i_dbgl )           // Debug option
 {
+    uint32_t     torMagic;
     uint32_t acc_offset = 0;   // Accumulating offset to next TOR offset slot
     uint32_t ring_offset = 0;
     uint16_t chiplet_offset = 0;
     uint32_t ringSize = 0;
     int temp = (i_ddLevelOffset >> 2) + 4;    // converting byte  to word counter
     uint32_t spge_offset = 0;
+    uint32_t ppe_cplt_offset = 0; // Local offset to where the pool of chiplets starts
+
+    torMagic = be32toh( ((TorHeader_t*)i_ringSection)->magic );
 
-    if (i_magic == P9_XIP_MAGIC_HW)
+    // Calculate the offset (wrt start of ringSection) to the SGPE PPE
+    //   ring section. This offset, inappropriately denoted "temp" here
+    //   but which needs to be renamed to "ppe_offset" asap, will point
+    //   to the TORG header of the SGPE PPE ring section.
+    if (torMagic == TOR_MAGIC_HW)
     {
         spge_offset = *((uint32_t*)i_ringSection + temp);  //DD level offset index
         temp = be32toh(spge_offset);
     }
-    else if (i_magic == P9_XIP_MAGIC_SGPE)
+    else if (torMagic == TOR_MAGIC_SGPE)
     {
         spge_offset = 0;
         i_ddLevelOffset = 0;
         temp = be32toh(spge_offset);
     }
+    else
+    {
+        MY_ERR("torMagic=0x%08x is not valid for SGPE\n", torMagic);
+        return TOR_INVALID_MAGIC_NUMBER;
+    }
+
+    // Calculate the offset (wrt start of ringSection) to where the
+    //   pool of chiplet offsets begins in the SGPE PPE ring section,
+    //   which is right after the TORG header.
+    ppe_cplt_offset = temp + sizeof(TorHeader_t);
 
     GenRingIdList* ring_id_list_common = NULL;
     GenRingIdList* ring_id_list_instance = NULL;
@@ -494,18 +525,18 @@ int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring sectio
                          RING_PROPERTIES[i_ringId].iv_name) == 0) && ( i_RingVariant == j ))
             {
                 strcpy(o_ringName, RING_PROPERTIES[i_ringId].iv_name);
-                uint32_t var = 0 + i_ddLevelOffset + temp;
+                uint32_t var = 0 + i_ddLevelOffset + ppe_cplt_offset;
                 int temp1 =  var / sizeof(uint32_t);
                 ring_offset =  *((uint32_t*)i_ringSection + temp1);
                 ring_offset = be32toh(ring_offset);
-                var = ring_offset + i_ddLevelOffset + temp;
+                var = ring_offset + i_ddLevelOffset + ppe_cplt_offset;
                 temp1 = var / sizeof(uint16_t) + local;
                 chiplet_offset  = *((uint16_t*)i_ringSection + temp1);
                 chiplet_offset = be16toh(chiplet_offset);
 
                 if (i_RingBlockType == GET_SINGLE_RING)
                 {
-                    var = ring_offset + chiplet_offset + i_ddLevelOffset + temp;
+                    var = ring_offset + chiplet_offset + i_ddLevelOffset + ppe_cplt_offset;
                     ringSize = be16toh( ((CompressedScanData*)
                                          ((uint8_t*)i_ringSection +
                                           var))->iv_size );
@@ -545,7 +576,7 @@ int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring sectio
                         {
                             MY_INF(" Hex details (SGPE):  Chiplet #%d offset 0x%08x  local offset 0x%08x  " \
                                    "ring offset 0x%08x  start adr 0x%08x  ringSize=0x%08x \n",
-                                   i, var, temp, ring_offset, chiplet_offset, ringSize);
+                                   i, var, ppe_cplt_offset, ring_offset, chiplet_offset, ringSize);
                         }
 
                         return TOR_RING_FOUND;
@@ -611,18 +642,18 @@ int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring sectio
                         if ( i == io_instanceId && k == i_RingVariant )
                         {
                             strcpy(o_ringName, RING_PROPERTIES[i_ringId].iv_name);
-                            uint32_t var = CPLT_OFFSET_SIZE + i_ddLevelOffset + temp;
+                            uint32_t var = CPLT_OFFSET_SIZE + i_ddLevelOffset + ppe_cplt_offset;
                             int temp1 =  var / sizeof(uint32_t);
                             ring_offset =  *((uint32_t*)i_ringSection + temp1);
                             ring_offset = be32toh(ring_offset);
-                            var = ring_offset + i_ddLevelOffset + temp;
+                            var = ring_offset + i_ddLevelOffset + ppe_cplt_offset;
                             temp1 = var / sizeof(uint16_t) + local;
                             chiplet_offset  = *((uint16_t*)i_ringSection + temp1);
                             chiplet_offset = be16toh(chiplet_offset);
 
                             if (i_RingBlockType == GET_SINGLE_RING)
                             {
-                                var = ring_offset + chiplet_offset + i_ddLevelOffset + temp;
+                                var = ring_offset + chiplet_offset + i_ddLevelOffset + ppe_cplt_offset;
                                 ringSize = be16toh( ((CompressedScanData*)
                                                      ((uint8_t*)i_ringSection +
                                                       var))->iv_size );
@@ -667,7 +698,7 @@ int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring sectio
                                     {
                                         MY_INF(" Hex details (SGPE):  Chiplet #%d offset 0x%08x  local offset 0x%08x  " \
                                                "ring offset 0x%08x  start adr 0x%08x  ringSize=0x%08x \n",
-                                               i, var, temp, ring_offset, chiplet_offset, ringSize);
+                                               i, var, ppe_cplt_offset, ring_offset, chiplet_offset, ringSize);
                                     }
 
                                     return TOR_RING_FOUND;
@@ -735,7 +766,6 @@ int get_ring_from_sgpe_image ( void*           i_ringSection,     // Ring sectio
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 static
 int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section ptr
-                              uint64_t        i_magic,           // Image Magic Number
                               RingID          i_ringId,          // Ring ID
                               uint16_t        i_ddLevelOffset,   // DD level offset
                               RingType_t&     io_RingType,       // Common, Instance
@@ -747,24 +777,38 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                               char*           o_ringName,        // Name of ring
                               uint32_t        i_dbgl )           // Debug option
 {
+    uint32_t torMagic;
     uint32_t acc_offset = 0;   // Accumulating offset to next TOR offset slot
     uint32_t ring_offset = 0;
     uint16_t chiplet_offset = 0;
     uint32_t ringSize = 0;
     int temp = (i_ddLevelOffset >> 2) + 2;  // converting byte  to word counter
     uint32_t cme_offset = 0;
+    uint32_t ppe_cplt_offset = 0; // Local offset to where the pool of chiplets starts
 
-    if (i_magic == P9_XIP_MAGIC_HW)
+    torMagic = be32toh( ((TorHeader_t*)i_ringSection)->magic );
+
+    if (torMagic == TOR_MAGIC_HW)
     {
         cme_offset = *((uint32_t*)i_ringSection + temp);  //DD level offset index
         temp = be32toh(cme_offset);
     }
-    else if (i_magic == P9_XIP_MAGIC_CME)
+    else if (torMagic == TOR_MAGIC_CME)
     {
         cme_offset = 0;
         i_ddLevelOffset = 0;
         temp = be32toh(cme_offset);
     }
+    else
+    {
+        MY_ERR("torMagic=0x%08x is not valid for CME\n", torMagic);
+        return TOR_INVALID_MAGIC_NUMBER;
+    }
+
+    // Calculate the offset (wrt start of ringSection) to where the
+    //   pool of chiplet offsets begins in the CME PPE ring section,
+    //   which is right after the TORC header.
+    ppe_cplt_offset = temp + sizeof(TorHeader_t);
 
     GenRingIdList* ring_id_list_common = NULL;
     GenRingIdList* ring_id_list_instance = NULL;
@@ -788,18 +832,18 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                          RING_PROPERTIES[i_ringId].iv_name) == 0) && ( i_RingVariant == j ))
             {
                 strcpy(o_ringName, RING_PROPERTIES[i_ringId].iv_name);
-                uint32_t var = 0 + i_ddLevelOffset + temp;
+                uint32_t var = 0 + i_ddLevelOffset + ppe_cplt_offset;
                 int temp1 =  var / sizeof(uint32_t);
                 ring_offset =  *((uint32_t*)i_ringSection + temp1);
                 ring_offset = be32toh(ring_offset);
-                var = ring_offset + i_ddLevelOffset + temp;
+                var = ring_offset + i_ddLevelOffset + ppe_cplt_offset;
                 temp1 = var / sizeof(uint16_t) + local;
                 chiplet_offset  = *((uint16_t*)i_ringSection + temp1);
                 chiplet_offset = be16toh(chiplet_offset);
 
                 if (i_RingBlockType == GET_SINGLE_RING)
                 {
-                    var = ring_offset + chiplet_offset + i_ddLevelOffset + temp;
+                    var = ring_offset + chiplet_offset + i_ddLevelOffset + ppe_cplt_offset;
                     ringSize = be16toh( ((CompressedScanData*)
                                          ((uint8_t*)i_ringSection +
                                           var))->iv_size );
@@ -839,7 +883,7 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                         {
                             MY_INF(" Hex details (CME):  Chiplet #%d offset 0x%08x  local offset 0x%08x  " \
                                    "ring offset 0x%08x  start adr 0x%08x  ringSize=0x%08x \n",
-                                   i, var, temp, ring_offset, chiplet_offset, ringSize);
+                                   i, var, ppe_cplt_offset, ring_offset, chiplet_offset, ringSize);
                         }
 
                         return TOR_RING_FOUND;
@@ -905,18 +949,18 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                         if ( i == io_instanceId && k == i_RingVariant )
                         {
                             strcpy(o_ringName, RING_PROPERTIES[i_ringId].iv_name);
-                            uint32_t var = CPLT_OFFSET_SIZE + i_ddLevelOffset + temp;
+                            uint32_t var = i_ddLevelOffset + ppe_cplt_offset + CPLT_OFFSET_SIZE;
                             int temp1 =  var / CPLT_OFFSET_SIZE;
                             ring_offset =  *((uint32_t*)i_ringSection + temp1);
                             ring_offset = be32toh(ring_offset);
-                            var = ring_offset + i_ddLevelOffset + temp;
+                            var = ring_offset + i_ddLevelOffset + ppe_cplt_offset;
                             temp1 = var / sizeof(uint16_t) + local;
                             chiplet_offset = *((uint16_t*)i_ringSection + temp1);
                             chiplet_offset = be16toh(chiplet_offset);
 
                             if (i_RingBlockType == GET_SINGLE_RING)
                             {
-                                var = ring_offset + chiplet_offset + i_ddLevelOffset + temp;
+                                var = ring_offset + chiplet_offset + i_ddLevelOffset + ppe_cplt_offset;
                                 ringSize = be16toh( ((CompressedScanData*)
                                                      ((uint8_t*)i_ringSection +
                                                       var))->iv_size );
@@ -947,7 +991,7 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                                     {
                                         MY_INF(" Hex details (CME):  Chiplet #%d offset 0x%08x  local offset 0x%08x  " \
                                                "ring offset 0x%08x  start adr 0x%08x  ringSize=0x%08x \n",
-                                               i, var, temp, ring_offset, chiplet_offset, ringSize);
+                                               i, var, ppe_cplt_offset, ring_offset, chiplet_offset, ringSize);
                                     }
 
                                     memcpy( (uint8_t*)(*io_ringBlockPtr), (uint8_t*)i_ringSection + var,
@@ -960,14 +1004,6 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                                         MY_INF(" After get_ring_from_cme_image Size %d \n", io_ringBlockSize);
                                     }
 
-                                    if (i_dbgl > 1)
-                                    {
-                                        MY_INF("  0x%08x 0x%08x 0x%08x 0x%08x 0x%08x \n",
-                                               var, temp, ring_offset, chiplet_offset, ringSize);
-                                        MY_INF("Chiplet %d   ChipletRing TOR offset  %d   %d  Size %d %d \t\n",
-                                               i,  ring_offset, chiplet_offset, ringSize, temp);
-                                    }
-
                                     return TOR_RING_FOUND;
                                 }
                                 else
@@ -986,6 +1022,7 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
                                 if (chiplet_offset)
                                 {
                                     MY_ERR("Ring container is already present in the CME section \n");
+
                                     return TOR_RING_AVAILABLE_IN_RINGSECTION;
                                 }
 
@@ -1032,7 +1069,6 @@ int get_ring_from_cme_image ( void*           i_ringSection,     // Ring section
 ///
 //////////////////////////////////////////////////////////////////////////////////////////
 int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
-                      uint64_t        i_magic,           // Image Magic Number
                       RingID          i_ringId,          // Ring ID
                       uint16_t        i_ddLevel,         // DD level
                       PpeType_t       i_PpeType,         // SBE, CME, SGPE
@@ -1046,12 +1082,15 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
                       uint32_t        i_dbgl )           // Debug option
 {
     int rc = 0;
+    uint32_t       torMagic;
+    TorHeader_t*   torHeader;
+    TorDdBlock_t*  torDdBlock;
     uint8_t  bDdCheck = 0;
     uint32_t ddLevelOffset = 0;
     uint32_t ddLevelCount = 0;
     uint32_t ddLevel = 0;
     uint32_t ddBlockSize = 0;
-    uint32_t temp = 0, local = 0;
+    uint32_t temp = 0;
 
 
     if (i_dbgl > 1)
@@ -1059,10 +1098,12 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
         MY_INF("Entering tor_access_ring()... \n");
     }
 
-    if (i_magic == P9_XIP_MAGIC_HW)
+    torHeader = (TorHeader_t*)i_ringSection;
+    torMagic = be32toh(torHeader->magic);
+
+    if (torMagic == TOR_MAGIC_HW)
     {
-        ddLevelCount =  *((uint32_t*)i_ringSection + 0);
-        ddLevelCount = be32toh(ddLevelCount);
+        ddLevelCount = torHeader->numDdLevels;
 
         if (ddLevelCount > MAX_NOOF_DD_LEVELS_IN_IMAGE)
         {
@@ -1078,14 +1119,14 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
             MY_INF("tor_access_ring(): No of DD levels: %d \n", ddLevelCount);
         }
 
-        // start at one since we use that as an offset
-        for (uint8_t i = 1; i <= ddLevelCount; i++)
+        for (uint8_t i = 0; i < ddLevelCount; i++)
         {
-            local = 2 * i;
-            ddLevelOffset  =  *((uint32_t*)i_ringSection + local);
-
-            ddLevel = be32toh(ddLevelOffset) >> 24 & 0x000000FF;
-            ddLevelOffset = be32toh(ddLevelOffset) & 0x00FFFFFF;
+            torDdBlock = (TorDdBlock_t*)( (uint8_t*)torHeader +
+                                          sizeof(TorHeader_t) +
+                                          i * sizeof(TorDdBlock_t) );
+            ddLevel = torDdBlock->ddLevel;
+            // Local ddLevelOffset
+            ddLevelOffset = be32toh(torDdBlock->offset);
 
             if (i_dbgl > 1)
             {
@@ -1095,11 +1136,10 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
 
             if ( ddLevel == i_ddLevel)
             {
-                ddLevelOffset = ddLevelOffset + sizeof(TorNumDdLevels_t);
-                local = local + 1;
-                ddBlockSize = *((uint32_t*)i_ringSection + local);
-                ddBlockSize = be32toh(ddBlockSize);
-
+                // Convert to global ddLevelOffset
+                ddLevelOffset = ddLevelOffset +
+                                sizeof(TorHeader_t);
+                ddBlockSize = htobe32(torDdBlock->size);
                 bDdCheck = 1;
                 break;
             }
@@ -1115,7 +1155,9 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
             return TOR_DD_LEVEL_NOT_FOUND;
         }
     }
-    else if ( i_magic ==  P9_XIP_MAGIC_SEEPROM)
+    else if ( torMagic == TOR_MAGIC_SBE  ||
+              torMagic == TOR_MAGIC_OVRD ||
+              torMagic == TOR_MAGIC_OVLY )
     {
         if ( i_PpeType == CME || i_PpeType == SGPE
              || i_RingBlockType == GET_DD_LEVEL_RINGS
@@ -1126,11 +1168,11 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
         }
         else
         {
-            ddLevelOffset = 0;
+            ddLevelOffset = sizeof(TorHeader_t);
             ddBlockSize = 0;
         }
     }
-    else if ( i_magic ==  P9_XIP_MAGIC_CME)
+    else if (torMagic == TOR_MAGIC_CME)
     {
         if ( i_PpeType == SBE || i_PpeType == SGPE
              || i_RingBlockType == GET_DD_LEVEL_RINGS
@@ -1141,11 +1183,11 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
         }
         else
         {
-            ddLevelOffset = 0;
+            ddLevelOffset = sizeof(TorHeader_t);
             ddBlockSize = 0;
         }
     }
-    else if ( i_magic ==  P9_XIP_MAGIC_SGPE)
+    else if (torMagic == TOR_MAGIC_SGPE)
     {
         if ( i_PpeType == SBE || i_PpeType == CME
              || i_RingBlockType == GET_DD_LEVEL_RINGS
@@ -1156,15 +1198,18 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
         }
         else
         {
-            ddLevelOffset = 0;
+            ddLevelOffset = sizeof(TorHeader_t);
             ddBlockSize = 0;
         }
     }
     else
     {
-        MY_ERR("Magic number i_magic=0x%016lX\n is not valid.\n", (uintptr_t)i_magic);
+        if (i_dbgl > 0)
+        {
+            MY_ERR("torMagic=0x%08x is not valid\n", torMagic);
+        }
 
-        return TOR_AMBIGUOUS_API_PARMS;
+        return TOR_INVALID_MAGIC_NUMBER;
     }
 
     if (i_RingBlockType == GET_DD_LEVEL_RINGS)
@@ -1275,22 +1320,23 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
     else if ( i_RingBlockType == GET_SINGLE_RING ||
               i_RingBlockType == PUT_SINGLE_RING )
     {
-        if (i_PpeType == SBE &&
-            ( i_magic == P9_XIP_MAGIC_HW ||
-              i_magic == P9_XIP_MAGIC_SEEPROM))
+        if ( i_PpeType == SBE &&
+             ( torMagic == TOR_MAGIC_HW   ||
+               torMagic == TOR_MAGIC_SBE  ||
+               torMagic == TOR_MAGIC_OVRD ||
+               torMagic == TOR_MAGIC_OVLY ) )
         {
-            rc = get_ring_from_sbe_image ( i_ringSection,
-                                           i_magic,
-                                           i_ringId,
-                                           ddLevelOffset,
-                                           io_RingType,
-                                           i_RingVariant,
-                                           io_instanceId,
-                                           i_RingBlockType,
-                                           io_ringBlockPtr,
-                                           io_ringBlockSize,
-                                           o_ringName,
-                                           i_dbgl);
+            rc = get_ring_from_sbe_image( i_ringSection,
+                                          i_ringId,
+                                          ddLevelOffset,
+                                          io_RingType,
+                                          i_RingVariant,
+                                          io_instanceId,
+                                          i_RingBlockType,
+                                          io_ringBlockPtr,
+                                          io_ringBlockSize,
+                                          o_ringName,
+                                          i_dbgl );
 
             if (rc)
             {
@@ -1312,22 +1358,21 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
                 return TOR_RING_BLOCKS_FOUND;
             }
         }
-        else if (i_PpeType == CME &&
-                 ( i_magic == P9_XIP_MAGIC_HW ||
-                   i_magic == P9_XIP_MAGIC_CME))
+        else if ( i_PpeType == CME &&
+                  ( torMagic == TOR_MAGIC_HW ||
+                    torMagic == TOR_MAGIC_CME ) )
         {
-            rc =  get_ring_from_cme_image ( i_ringSection,
-                                            i_magic,
-                                            i_ringId,
-                                            ddLevelOffset,
-                                            io_RingType,
-                                            i_RingVariant,
-                                            io_instanceId,
-                                            i_RingBlockType,
-                                            io_ringBlockPtr,
-                                            io_ringBlockSize,
-                                            o_ringName,
-                                            i_dbgl);
+            rc =  get_ring_from_cme_image( i_ringSection,
+                                           i_ringId,
+                                           ddLevelOffset,
+                                           io_RingType,
+                                           i_RingVariant,
+                                           io_instanceId,
+                                           i_RingBlockType,
+                                           io_ringBlockPtr,
+                                           io_ringBlockSize,
+                                           o_ringName,
+                                           i_dbgl );
 
             if (rc == TOR_RING_NOT_FOUND)
             {
@@ -1379,22 +1424,21 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
                 return TOR_RING_BLOCKS_FOUND;
             }
         }
-        else if (i_PpeType == SGPE &&
-                 ( i_magic == P9_XIP_MAGIC_HW ||
-                   i_magic == P9_XIP_MAGIC_SGPE))
+        else if ( i_PpeType == SGPE &&
+                  ( torMagic == TOR_MAGIC_HW ||
+                    torMagic == TOR_MAGIC_SGPE ) )
         {
-            rc =  get_ring_from_sgpe_image ( i_ringSection,
-                                             i_magic,
-                                             i_ringId,
-                                             ddLevelOffset,
-                                             io_RingType,
-                                             i_RingVariant,
-                                             io_instanceId,
-                                             i_RingBlockType,
-                                             io_ringBlockPtr,
-                                             io_ringBlockSize,
-                                             o_ringName,
-                                             i_dbgl);
+            rc =  get_ring_from_sgpe_image( i_ringSection,
+                                            i_ringId,
+                                            ddLevelOffset,
+                                            io_RingType,
+                                            i_RingVariant,
+                                            io_instanceId,
+                                            i_RingBlockType,
+                                            io_ringBlockPtr,
+                                            io_ringBlockSize,
+                                            o_ringName,
+                                            i_dbgl );
 
             if (rc == TOR_RING_NOT_FOUND)
             {
@@ -1448,10 +1492,11 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
         }
         else
         {
-            MY_ERR("\t Code bug: We are unpreparred for this input parm combination: \n"
-                   "\t i_PpeType=%d\n"
-                   "\t i_magic=0x%016lX\n",
-                   i_PpeType, (uintptr_t)i_magic);
+            if (i_dbgl > 0)
+            {
+                MY_ERR("\t Unsupported combination of i_PpeType=%d and torMagic=0x%08x\n",
+                       i_PpeType, torMagic);
+            }
 
             return TOR_AMBIGUOUS_API_PARMS;
         }
@@ -1466,7 +1511,8 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
     }
 
     return TOR_AMBIGUOUS_API_PARMS;
-}
+
+} // End of tor_access_ring()
 
 
 
@@ -1476,7 +1522,6 @@ int tor_access_ring(  void*           i_ringSection,     // Ring section ptr
 //
 /////////////////////////////////////////////////////////////////////////////////////
 int tor_get_single_ring ( void*         i_ringSection,     // Ring section ptr
-                          uint64_t      i_magic,           // Image Magic Number
                           uint16_t      i_ddLevel,         // DD level
                           RingID        i_ringId,          // Ring ID
                           PpeType_t     i_PpeType,         // SBE, CME, SGPE
@@ -1489,7 +1534,7 @@ int tor_get_single_ring ( void*         i_ringSection,     // Ring section ptr
 
     uint32_t rc;
     char i_ringName[25];
-    uint8_t l_instanceId = i_instanceId;
+    //@FIXME: This should really be ALLRING. But it's not used as input.
     RingType_t l_ringType;
     l_ringType = COMMON;
 
@@ -1499,13 +1544,12 @@ int tor_get_single_ring ( void*         i_ringSection,     // Ring section ptr
     }
 
     rc = tor_access_ring( i_ringSection,
-                          i_magic,
                           i_ringId,
                           i_ddLevel,
                           i_PpeType,
                           l_ringType,
                           i_RingVariant,
-                          l_instanceId,
+                          i_instanceId,
                           GET_SINGLE_RING,
                           io_ringBlockPtr,
                           io_ringBlockSize,
@@ -1531,7 +1575,7 @@ int tor_get_single_ring ( void*         i_ringSection,     // Ring section ptr
 int tor_get_block_of_rings ( void*           i_ringSection,     // Ring section ptr
                              uint16_t        i_ddLevel,         // DD level
                              PpeType_t       i_PpeType,         // SBE,CME,SGPE
-                             RingType_t      i_RingType,        // Common, Instance
+                             RingType_t      i_ringType,        // Common, Instance
                              RingVariant_t   i_RingVariant,     // Base,CC, RL, Ovrd, Ovly
                              uint8_t         i_instanceId,      // Instance ID
                              void**          io_ringBlockPtr,   // Output ring buffer
@@ -1545,20 +1589,17 @@ int tor_get_block_of_rings ( void*           i_ringSection,     // Ring section
 
     uint32_t rc = 0;
     char i_ringName[25];
-    uint8_t l_instanceId  = i_instanceId;
-    RingType_t l_ringType = i_RingType;
 
-    if (l_ringType == ALLRING && i_PpeType != NUM_PPE_TYPES)
+    if (i_ringType == ALLRING && i_PpeType != NUM_PPE_TYPES)
     {
         // Get block of rings specific to a PPE type
         rc = tor_access_ring( i_ringSection,
-                              P9_XIP_MAGIC_HW,
                               NUM_RING_IDS,
                               i_ddLevel,
                               i_PpeType,
-                              l_ringType,
+                              i_ringType,
                               i_RingVariant,
-                              l_instanceId,
+                              i_instanceId,
                               GET_PPE_LEVEL_RINGS,
                               io_ringBlockPtr,
                               io_ringBlockSize,
@@ -1566,17 +1607,16 @@ int tor_get_block_of_rings ( void*           i_ringSection,     // Ring section
                               i_dbgl );
 
     }
-    else if (l_ringType == ALLRING && i_PpeType == NUM_PPE_TYPES)
+    else if (i_ringType == ALLRING && i_PpeType == NUM_PPE_TYPES)
     {
         // Get DD level block of rings
         rc = tor_access_ring( i_ringSection,
-                              P9_XIP_MAGIC_HW,
                               NUM_RING_IDS,
                               i_ddLevel,
                               i_PpeType,
-                              l_ringType,
+                              i_ringType,
                               i_RingVariant,
-                              l_instanceId,
+                              i_instanceId,
                               GET_DD_LEVEL_RINGS,
                               io_ringBlockPtr,
                               io_ringBlockSize,
@@ -1622,39 +1662,17 @@ int tor_append_ring(  void*           i_ringSection,      // Ring section ptr
     char       i_ringName[25];
     uint32_t   l_buf = 0;
     uint32_t*  l_cpltSection = &l_buf;
-    uint8_t    l_instanceId  = i_instanceId;
-    RingType_t l_RingType = i_RingType;
     uint32_t   l_ringBlockSize;
     uint16_t   l_ringOffset16;
-    uint64_t   l_magic;
     uint32_t   l_torOffsetSlot;
 
-    if (i_PpeType  == SBE)  // Assign i_magic variant as SBE image
-    {
-        l_magic = P9_XIP_MAGIC_SEEPROM;
-    }
-    else if (i_PpeType == CME)  // Assign i_magic variant as CME image
-    {
-        l_magic = P9_XIP_MAGIC_CME;
-    }
-    else if (i_PpeType == SGPE) // Assign i_magic variant as SGPE image
-    {
-        l_magic = P9_XIP_MAGIC_SGPE;
-    }
-    else
-    {
-        MY_ERR("PPE type (i_PpeType=%d) is not supported \n", i_PpeType);
-        return TOR_AMBIGUOUS_API_PARMS;
-    }
-
     rc = tor_access_ring( i_ringSection,
-                          l_magic,
                           i_ringId,
                           0x00,
                           i_PpeType,
-                          l_RingType,
+                          i_RingType,
                           i_RingVariant,
-                          l_instanceId,
+                          i_instanceId,
                           PUT_SINGLE_RING,
                           (void**)&l_cpltSection, // On return, contains offset (wrt ringSection) of
                           // chiplet section's common or instance section
@@ -1665,7 +1683,11 @@ int tor_append_ring(  void*           i_ringSection,      // Ring section ptr
 
     if (rc)
     {
-        MY_ERR("tor_access_ring() failed w/rc=0x%x \n", rc);
+        if (i_dbgl > 0)
+        {
+            MY_ERR("tor_append_ring() failed in call to tor_access_ring w/rc=0x%x \n", rc);
+        }
+
         return rc;
     }
 
@@ -1700,6 +1722,10 @@ int tor_append_ring(  void*           i_ringSection,      // Ring section ptr
     // Update the ringSectionSize
     io_ringSectionSize += l_ringBlockSize;
 
+    // Update also the size in the TOR header
+    TorHeader_t* torHeader = (TorHeader_t*)i_ringSection;
+    torHeader->size = htobe32(be32toh(torHeader->size) + l_ringBlockSize);
+
     return TOR_SUCCESS;
 }
 
diff --git a/src/import/chips/p9/utils/imageProcs/p9_tor.H b/src/import/chips/p9/utils/imageProcs/p9_tor.H
index 94b5274..cc8f15a 100644
--- a/src/import/chips/p9/utils/imageProcs/p9_tor.H
+++ b/src/import/chips/p9/utils/imageProcs/p9_tor.H
@@ -25,7 +25,6 @@
 #ifndef _P9_TOR_H_
 #define _P9_TOR_H_
 
-#include "p9_ring_id.h"
 #include "p9_ringId.H"
 
 #define MAX_TOR_RING_OFFSET  (256*256-1)  // Max value of 2Byte uint
@@ -36,7 +35,7 @@ namespace P9_TOR
 extern const char* ppeTypeName[];
 extern const char* ringVariantName[];
 
-#define  TOR_VERSION  2
+#define  TOR_VERSION  3
 
 //
 // TOR Magic values for top-level TOR image and TOR sub-images
@@ -53,7 +52,34 @@ enum TorMagicNum
     TOR_MAGIC_CEN   = (uint32_t)0x544F524E,   // "TORN"
 };
 
+//
+// Chip types to represent p9n, p9c, centaur
+//
+enum ChipType
+{
+    CT_P9N,
+    CT_P9C,
+    CT_CEN,
+    NUM_CHIP_TYPES
+};
+
 typedef uint8_t ChipType_t;
+const ChipType_t INVALID_CHIP_TYPE = 0xff;
+
+typedef struct ChipTypeList
+{
+    const char* name;
+    ChipType_t  type;
+} ChipTypeList_t;
+
+const ChipTypeList_t CHIP_TYPE_LIST[] =
+{
+    {"p9n",     CT_P9N},
+    {"p9c",     CT_P9C},
+    {"cen",     CT_CEN},
+};
+
+
 
 //
 // TOR header field (appears in top of every HW, SBE, CEN, OVRD, etc ring section)
@@ -65,26 +91,26 @@ typedef struct
     ChipType_t chipType;    // Value from ChipType enum
     uint8_t    ddLevel;     // =0xff if MAGIC_HW, >0 all other MAGICs
     uint8_t    numDdLevels; // >0 if MAGIC_HW, =1 all other MAGICs
-    uint32_t   size;        // Size of the TOR ringSection.
+    uint32_t   size;        // A place holder for now, but will be used in a later commit.
 } TorHeader_t;
 
+#define UNDEFINED_DD_LEVEL (uint8_t)0xff
 
+//
+// Subsequent TOR fields (listed in order they appear in TOR for easier understanding)
+//
 typedef struct
 {
-    uint32_t TorNumDdLevels;
-    uint32_t reserved;
-} TorNumDdLevels_t;
-
-typedef struct
-{
-    uint32_t TorDdLevelAndOffset;
-    uint32_t TorDdBlockSize;
-} TorDdLevelBlock_t;
+    uint32_t offset;
+    uint32_t size;
+    uint8_t  ddLevel;
+    uint8_t  reserved[3];
+} TorDdBlock_t;
 
 typedef struct
 {
-    uint32_t TorPpeTypeOffset;
-    uint32_t TorPpeBlockSize;
+    uint32_t offset;
+    uint32_t size;
 } TorPpeBlock_t;
 
 typedef struct
@@ -95,6 +121,13 @@ typedef struct
 
 typedef uint16_t TorRingOffset_t;  // Ring offset value in TOR offset slot
 
+//@FIXME Discard asap
+typedef enum TorOffsetSize
+{
+    RING_OFFSET_SIZE = 2,
+    CPLT_OFFSET_SIZE = 4
+} TorOffsetSize_t;
+
 #define TOR_SUCCESS                           0
 #define TOR_RING_FOUND                        0
 #define TOR_RING_BLOCKS_FOUND                 0
@@ -117,6 +150,7 @@ typedef uint16_t TorRingOffset_t;  // Ring offset value in TOR offset slot
 #define TOR_BUFFER_TOO_SMALL                 17
 #define TOR_TOO_MANY_DD_LEVELS               18
 #define TOR_OFFSET_TOO_BIG                   19
+#define TOR_INVALID_VARIANT                  20
 
 // Different options to extract data using tor_access_ring API
 typedef enum RingBlockType
@@ -142,12 +176,6 @@ typedef enum PpeType
     NUM_PPE_TYPES = 0x03
 } PpeType_t;
 
-typedef enum TorOffsetSize
-{
-    RING_OFFSET_SIZE = 2,
-    CPLT_OFFSET_SIZE = 4
-} TorOffsetSize_t;
-
 ///
 /// ****************************************************************************
 /// Function declares.
@@ -161,9 +189,6 @@ typedef enum TorOffsetSize
 /// TOR API supports two type of binary image. 1) HW image format and 2)
 /// SEEPROM image format binary
 ///
-/// \param[in]  i_magic A uint64_t variable to indicate XIP image format
-/// ring section passed
-///
 /// \param[in]  i_ringId A enum to indicate unique ID for the ring
 ///
 /// \param[in]  i_ddLevel A variable to indicate chip DD level. TOR API
@@ -211,8 +236,7 @@ typedef enum TorOffsetSize
 /// and the following n number of operation based on the call.
 ///
 /// GET_SINGLE_RING (\a i_ringVariant) - traverse on \a i_ringSection buffer
-/// based on the following input param \a i_magic which gives details of image
-/// type, \a i_ringId which gives ring info, \a i_ddLevel which gives dd spec
+/// based on \a i_ringId which gives ring info, \a i_ddLevel which gives dd spec
 /// (Used only for HW image/optional for other image) i_ppeType which gives ppe
 /// type info, \a i_ringVarint gives ring variant info and \a io_instance which
 /// gives chiplet instance specific while accessing instance specific ring and
@@ -222,33 +246,29 @@ typedef enum TorOffsetSize
 /// data copied into io_ringBlockPtr. \a o_ringName returns ring string name.
 ///
 /// GET_DD_LEVEL_RINGS (\a i_ringVariant) - traverse on \a i_ringSection
-/// buffer based on the following input param \a i_magic which gives details
-/// of image type and \a i_ddLevel which gives dd spec(Used only for HW image
+/// buffer based on \a i_ddLevel which gives dd spec (used only for HW image
 /// /optional  for other image) On return, \a io_ringBlockPtr contains DD level
 /// specific ring section and \a io_ringBlockSize contains size of the data
 /// copied into io_ringBlockPtr. \a Other params are optional.
 /// This ringVariant works on HW image.
 ///
 /// GET_PPE_LEVEL_RINGS (\a i_ringVariant) - traverse on \a i_ringSection
-/// buffer based on the following input param \a i_magic which gives the detail
-/// of image type, i_ppeType which gives ppe type info  and \a i_ddLevel which
-/// gives dd spec(Used only for HW image/optional for other image) On return,
+/// buffer based on \a i_ppeType which gives ppe type info  and \a i_ddLevel which
+/// gives dd spec used only for HW image/optional for other image) On return,
 /// \a io_ringBlockPtr contains PPE type specific ring section and
 /// \a io_ringBlockSize contains size of the data copied into io_ringBlockPtr.
 /// \a Other params are optional. This ringVariant works on HW image.
 ///
 /// GET_CPLT_LEVEL_RINGS (\a i_ringVariant) - traverse on \a i_ringSection
-/// buffer based on the following input param \a i_magic which gives the detail
-/// of image type, i_ppeType which gives ppe type info, \a i_ddLevel which gives
-/// dd spec(Used only for HW image/optional for other image) and \a io_RingType
+/// buffer based on \a i_ppeType which gives ppe type info, \a i_ddLevel which gives
+/// dd spec (used only for HW image/optional for other image) and \a io_RingType
 /// which gives ring type info. On return, \a io_ringBlockPtr contains chiplet
 /// specific ring type ring section and \a io_ringBlockSize contains size of
 /// the data copied into io_ringBlockPtr. \a Other params are optional.
 ///
 /// PUT_SINGLE_RING (\a i_ringVariant) - traverse on \a i_ringSection buffer
-/// based on the following input param \a i_magic which gives detail of image
-/// type, \a i_ringId which gives ring info, \a i_ddLevel which gives dd spec
-/// (Used only for HW image/optional for other image), i_ppeType which gives
+/// based on \a i_ringId which gives ring info, \a i_ddLevel which gives dd spec
+/// (used only for HW image/optional for other image), i_ppeType which gives
 /// ppe type info, \a i_ringVarint gives ring variant info and \a io_instance
 /// which gives chiplet instance specific while accessing instance specific
 /// ring and returns chiplet number while accessing common ring. On return,
@@ -261,7 +281,6 @@ typedef enum TorOffsetSize
 ///
 /// \retval non-0 See \ref TOR API RETURN errors
 int tor_access_ring( void*           i_ringSection, // Ring address Ptr any of .rings, .overrides and .overlays.
-                     uint64_t        i_magic,          // Image Magic Number
                      RingID          i_ringId,         // Unique ring ID
                      uint16_t        i_ddLevel,        // DD level info
                      PpeType_t       i_PpeType,        // PPE type : SBE, CME, etc
@@ -282,9 +301,6 @@ int tor_access_ring( void*           i_ringSection, // Ring address Ptr any of .
 /// It contain details of p9 Ring which is used for scanning operation.
 /// TOR API supports HW image format  only
 ///
-/// \param[in]  i_magic A uint64_t variable to indicate XIP image format
-/// ring section passed
-///
 /// \param[in]  i_ringId A enum to indicate unique ID for the ring
 ///
 /// \param[in]  i_ddLevel A variable to indicate chip DD level. TOR API
@@ -316,7 +332,6 @@ int tor_access_ring( void*           i_ringSection, // Ring address Ptr any of .
 ///
 /// \retval non-0 See \ref TOR API RETURN errors
 int tor_get_single_ring ( void*          i_ringSection,
-                          uint64_t       i_magic,          // Image Magic Number
                           uint16_t       i_ddLevel,
                           RingID         i_ringId,
                           PpeType_t      i_PpeType,
-- 
1.8.2.2

