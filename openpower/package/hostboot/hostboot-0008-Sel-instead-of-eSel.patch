From d38ee0ae88993dee7b2d703340cf374d107ddfba Mon Sep 17 00:00:00 2001
From: Brian Horton <brianh@linux.ibm.com>
Date: Mon, 2 Mar 2015 12:12:28 -0600
Subject: [PATCH] send down SEL instead of eSEL for hostboot errorlogs

Change-Id: I86ee9766e27548c3f7f72fbdbfd76c8a8be7da73
RTC: 124971
---
 src/include/usr/ipmi/ipmisel.H |  2 ++
 src/usr/ipmi/ipmisel.C         | 49 +++++++++++++++++++++++++++++++++++-------
 2 files changed, 43 insertions(+), 8 deletions(-)

diff --git a/src/include/usr/ipmi/ipmisel.H b/src/include/usr/ipmi/ipmisel.H
index de2dd32..938cfdb 100644
--- a/src/include/usr/ipmi/ipmisel.H
+++ b/src/include/usr/ipmi/ipmisel.H
@@ -85,6 +85,7 @@ namespace IPMISEL
         format_ipmi_version_2_0 = 0x04,
     };
 
+    // event_type, per section 42.1 of the IPMI spec
     enum sel_event_dir_type
     {
         event_unspecified       = 0x00,
@@ -93,6 +94,7 @@ namespace IPMISEL
         event_predictive        = 0x04,
         event_limit             = 0x05,
         event_permformance      = 0x06,
+        event_OEM               = 0x70,
     };
 
     enum sel_event_data
diff --git a/src/usr/ipmi/ipmisel.C b/src/usr/ipmi/ipmisel.C
index c05c60f..4eec588 100644
--- a/src/usr/ipmi/ipmisel.C
+++ b/src/usr/ipmi/ipmisel.C
@@ -100,7 +100,12 @@ void sendESEL(uint8_t* i_eselData, uint32_t i_dataSize,
 
     // create the sel record of information
     selRecord l_sel;
+#if 1
+// TODO RTC: 124972 take this out and do the eSEL instead
+    l_sel.record_type = record_type_system_event;
+#else
     l_sel.record_type = record_type_ami_esel;
+#endif
     l_sel.generator_id = generator_id_ami;
     l_sel.evm_format_version = format_ipmi_version_2_0;
     l_sel.sensor_type = i_sensorType;
@@ -216,13 +221,40 @@ void send_esel(eselInitData * i_data,
 {
     IPMI_TRAC(ENTER_MRK "send_esel");
     uint8_t* data = NULL;
-    const size_t l_eSELlen = i_data->dataSize;
 
     size_t len = 0;
-    uint8_t reserveID[2] = {0,0};
-    uint8_t esel_recordID[2] = {0,0};
+    uint8_t sel_recordID[2] = {0,0};
 
     do{
+#if 1
+// TODO RTC: 124972 take this out and do the eSEL instead
+// do SEL instead
+        delete [] data;
+        len = sizeof(IPMISEL::selRecord);
+        data = new uint8_t[len];
+
+        // copy in the SEL event record data
+        memcpy(data, i_data->eSel, sizeof(IPMISEL::selRecord));
+
+        o_cc = IPMI::CC_UNKBAD;
+        TRACFBIN( g_trac_ipmi, INFO_MRK"add_sel:", data, len);
+        o_err = IPMI::sendrecv(IPMI::add_sel(),o_cc,len,data);
+        if(o_err)
+        {
+            IPMI_TRAC(ERR_MRK "error from add_sel");
+            break;
+        }
+        if (o_cc != IPMI::CC_OK)
+        {
+            IPMI_TRAC(ERR_MRK "failed add_sel, o_cc %02x", o_cc);
+            break;
+        }
+        sel_recordID[0] = data[0];
+        sel_recordID[1] = data[1];
+#else
+
+        const size_t l_eSELlen = i_data->dataSize;
+        uint8_t reserveID[2] = {0,0};
         // we need to send down the extended sel data (eSEL), which is
         // longer than the protocol buffer, so we need to do a reservation and
         // call the AMI partial_add_esel command multiple times
@@ -253,7 +285,7 @@ void send_esel(eselInitData * i_data,
         data = new uint8_t[len];
 
         // fill in the partial_add_esel request (command) data
-        createPartialAddHeader(reserveID,esel_recordID,eSELindex,l_lastEntry,data);
+        createPartialAddHeader(reserveID,sel_recordID,eSELindex,l_lastEntry,data);
 
         // copy in the SEL event record data
         memcpy(&data[PARTIAL_ADD_ESEL_REQ], i_data->eSel,
@@ -280,7 +312,7 @@ void send_esel(eselInitData * i_data,
         }
         // BMC returns the recordID, it's always the same (unless
         // there's a major BMC bug...)
-        storeReserveRecord(esel_recordID,data);
+        storeReserveRecord(sel_recordID,data);
 
         // now send down the eSEL data in chunks.
         const size_t l_maxBuffer = IPMI::max_buffer();
@@ -304,7 +336,7 @@ void send_esel(eselInitData * i_data,
             data = new uint8_t[len];
 
             // fill in the partial_add_esel request (command) data
-            createPartialAddHeader(reserveID, esel_recordID,
+            createPartialAddHeader(reserveID, sel_recordID,
                     eSELindex + sizeof(selRecord),
                     l_lastEntry, data);
 
@@ -337,8 +369,9 @@ void send_esel(eselInitData * i_data,
             }
             // BMC returns the recordID, it's always the same (unless
             // there's a major BMC bug...)
-            storeReserveRecord(esel_recordID,data);
+            storeReserveRecord(sel_recordID,data);
         }
+#endif
         if(o_err || (o_cc != IPMI::CC_OK))
         {
             break;
@@ -348,7 +381,7 @@ void send_esel(eselInitData * i_data,
     delete[] data;
 
     IPMI_TRAC(EXIT_MRK "send_esel (o_err %.8X, o_cc x%.2x, recID=x%x%x)",
-        o_err ? o_err->plid() : NULL, o_cc, esel_recordID[1], esel_recordID[0]);
+        o_err ? o_err->plid() : NULL, o_cc, sel_recordID[1], sel_recordID[0]);
 
     return;
 } // send_esel
-- 
1.8.2.2

